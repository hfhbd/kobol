{
  parserClass="app.softwork.kobol.CobolParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Cobol"
  psiImplClassSuffix="Impl"
  psiPackage="app.softwork.kobol"
  psiImplPackage="app.softwork.kobol.impl"

  elementTypeHolderClass="app.softwork.kobol.CobolTypes"
  elementTypeClass="app.softwork.kobol.CobolElementType"
  tokenTypeClass="app.softwork.kobol.CobolTokenType"

  tokens=[
    lineNumber="regexp:\r?\n\d{6}(\s|\*)"
    varName="regexp:[a-zA-Z]([\w\-_])*"
    space="regexp:\s+"
    comment="regexp:\*.*\r?\n\d{6}(\s|\*)"
    number="regexp:\+?(\d+(\.\d+)?)|(\.\d+)"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    any="regexp:.*\."
    twoDigits="regexp:\d{2}"
  ]

//  extends(".*_file")=file
}

//root ::= root_item *
//private root_item ::= !<<eof>> exps '.' {pin=1 recoverWhile=exps_recover}
root ::= program

program ::= comments idDiv [envDiv] [dataDiv] procedureDiv

comments ::= (comment) *

DOT ::= '.'
LP ::= '('
RP ::= ')'


idDiv ::= IDENTIFICATION DIVISION DOT programID_clause [other]

private other ::= (author_clause | installation_clause | date_clause ) *

programID_clause ::= comments PROGRAM-ID [DOT] varName DOT
author_clause ::= comments AUTHOR anys
installation_clause ::= comments INSTALLATION anys
date_clause ::= comments DATE-WRITTEN anys

anys ::= any *

envDiv ::=  comments ENVIRONMENT DIVISION DOT [config] [inputSection]
config ::= comments CONFIGURATION SECTION DOT [specialNames_def]
specialNames_def ::= comments SPECIAL-NAMES DOT [specialNameDeclaration* DOT]
specialNameDeclaration ::= comments specialName
specialName ::= specialNameEnv IS specialNameValue
specialNameEnv ::= varName
specialNameValue ::= varName

inputSection ::= comments INPUT-OUTPUT SECTION DOT [fileControl_clause]
fileControl_clause ::= comments FILE-CONTROL DOT fileConfig*
fileConfig ::= comments fileConfigSelect fileConfigAssign fileConfigStatus DOT
fileConfigSelect ::= SELECT varName
fileConfigAssign ::= ASSIGN [TO] varName
fileConfigStatus ::= FILE STATUS varName

dataDiv ::= comments DATA DIVISION DOT comments [fileSection] [workingStorageSection] [linkingSection]

fileSection ::= comments FILE SECTION DOT fileDescriptions*
recording_clause ::= RECORDING varName
block_clause ::= BLOCK number
fileRecord ::= RECORD number
label_clause ::= LABEL RECORD STANDARD
fileDescriptions ::= fileDescription | record_def*
fileDescription ::= comments FD varName recording_clause [block_clause] [fileRecord] label_clause dataRecord DOT
dataRecord ::= DATA RECORD varName

workingStorageSection ::= comments WORKING-STORAGE SECTION DOT stm*

stm ::= record_def | exec_sql_def
exec_sql_def ::= comments exec_sql DOT
exec_sql ::= EXEC SQL anys* END-EXEC

record_def ::= comments number [varName] (redefines_clause | pointer_clause | pic_clause )  DOT
pointer_clause ::= POINTER [VALUE var]
redefines_clause ::= REDEFINES varName
pic_clause ::= [PIC pic_def_clause+] [[USAGE] (COMP | COMP-3)] [BINARY] [VALUE var] [occurs_clause]
occurs_clause ::= OCCURS number [TO number] [DEPENDING ON varName]
pictures ::= X | A | S9 | pic_9 | V9 | plus | Z | B
pic_9 ::= '9'
plus ::= '+'
pic_def_clause ::= pictures [length]

length ::= LP number RP

linkingSection ::= LINKAGE SECTION DOT record_def*

procedureDiv ::= comments PROCEDURE DIVISION [USING varName] DOT [sentences*] [procedureSection*]
procedureSection ::= comments varName SECTION DOT sentences
sentences ::= procedures+ DOT
procedures ::= comments (displaying | moving | performing | if_clause | GOBACK | init_clause | exec_sql | opening | closing | calling | CONTINUE | reading | nextSentence | adding | eval )
adding ::= ADD expr TO varNames+
reading ::= READ varName [AT END procedures+] [NOT AT END procedures+] END-READ
nextSentence ::= NEXT SENTENCE
closing ::= CLOSE varName
calling ::= CALL expr [USING varNames+]
opening ::= OPEN (INPUT | OUTPUT) varName
init_clause ::= INITIALIZE varNames+
performing ::= performing_short | performing_long
performing_short ::= PERFORM varName [UNTIL boolean_expr]
performing_long ::= PERFORM UNTIL boolean_expr procedures+ END-PERFORM
moving ::= MOVE expr TO varNames+
varNames ::= varName
if_clause ::= IF boolean_expr procedures* [ELSE procedures*] END-IF
eval ::= EVALUATE variable whens* END-EVALUATE
whens ::= WHEN (expr | OTHER) procedures*
boolean_expr ::= (boolean_expr_clause OR boolean_expr_clause) | (boolean_expr_clause AND boolean_expr_clause) | boolean_expr_clause
boolean_expr_clause ::= expr [NOT] EQUAL expr
expr ::= var | variable | stringConcat

var ::= string | number | SPACE | HIGH-VALUE | LOW-VALUE | ZERO | NULL

variable ::= varName [LP expr colon expr RP] [of_clause]
of_clause ::= OF varName
colon ::= ':'

displaying ::= DISPLAY stringConcat
stringConcat ::= (string | variable) +
