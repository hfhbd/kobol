{
  parserClass="app.softwork.kobol.CobolParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Cobol"
  psiImplClassSuffix="Impl"
  psiPackage="app.softwork.kobol"
  psiImplPackage="app.softwork.kobol.impl"

  elementTypeHolderClass="app.softwork.kobol.CobolTypes"
  elementTypeClass="app.softwork.kobol.CobolElementType"
  tokenTypeClass="app.softwork.kobol.CobolTokenType"

  tokens=[
    lineNumber="regexp:\r?\n\d{6}(\s|\*)"
    varName="regexp:[a-zA-Z]([\w\-_])*"
    space="regexp:\s+"
    comment="regexp:\*.*\r?\n\d{6}(\s|\*)"
    number="regexp:([+\-])?(\d+(\.\d+)?)|(\.\d+)"
    string="regexp:X?('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    any="regexp:.*\."
    twoDigits="regexp:\d{2}"
    PIC9='9'
    PLUS='+'
    DOT='.'
    LP='('
    RP=')'
  ]

//  extends(".*_file")=file
}

//root ::= root_item *
//private root_item ::= !<<eof>> exps '.' {pin=1 recoverWhile=exps_recover}
root ::= program

program ::= comments idDiv [envDiv] [dataDiv] procedureDiv

comments ::= (comment) *

idDiv ::= IDENTIFICATION DIVISION DOT programID_clause [other]

private other ::= (author_clause | installation_clause | date_clause ) *

programID_clause ::= comments PROGRAM-ID [DOT] varName DOT
author_clause ::= comments AUTHOR anys
installation_clause ::= comments INSTALLATION anys
date_clause ::= comments DATE-WRITTEN anys

anys ::= any *

envDiv ::=  comments ENVIRONMENT DIVISION DOT [config] [inputSection]
config ::= comments CONFIGURATION SECTION DOT [specialNames_def]
specialNames_def ::= comments SPECIAL-NAMES DOT [specialNameDeclaration* DOT]
specialNameDeclaration ::= comments specialName
specialName ::= specialNameEnv IS specialNameValue
specialNameEnv ::= varName
specialNameValue ::= varName

inputSection ::= comments INPUT-OUTPUT SECTION DOT [fileControl_clause]
fileControl_clause ::= comments FILE-CONTROL DOT fileConfig*
fileConfig ::= comments fileConfigSelect fileConfigAssign fileConfigStatus DOT
fileConfigSelect ::= SELECT varName
fileConfigAssign ::= ASSIGN [TO] varName
fileConfigStatus ::= FILE STATUS varName

dataDiv ::= comments DATA DIVISION DOT comments [fileSection] [workingStorageSection] [linkingSection]

fileSection ::= comments FILE SECTION DOT fileDescriptions*
recording_clause ::= RECORDING varName
block_clause ::= BLOCK number [RECORDS]
fileRecord ::= RECORD number [TO number]
label_clause ::= LABEL RECORD STANDARD
fileDescriptions ::= fileDescription | record_def*
fileDescription ::= comments FD varName recording_clause [block_clause] [fileRecord] label_clause dataRecord DOT
dataRecord ::= DATA RECORD varName

workingStorageSection ::= comments WORKING-STORAGE SECTION DOT stm*

stm ::= record_def | exec_sql_def
exec_sql_def ::= comments exec_sql DOT
exec_sql ::= EXEC SQL anys* END-EXEC

record_def ::= comments number [varName] (redefines_clause | pointer_clause | pic_clause )  DOT
pointer_clause ::= POINTER [VALUE literal]
redefines_clause ::= REDEFINES varName
pic_clause ::= [PIC pic_def_clause+] [[USAGE] (COMP | COMP-3)] [BINARY] [VALUE literal] [occurs_clause]
occurs_clause ::= OCCURS number [TO number] [DEPENDING ON varName]
pictures ::= X | A | S9 | PIC9 | V9 | PLUS | Z | B
pic_def_clause ::= pictures [length]

length ::= LP number RP

linkingSection ::= LINKAGE SECTION DOT record_def*

procedureDiv ::= comments PROCEDURE DIVISION [USING varName] DOT [sentences+] [procedureSection*] endComments
endComments ::= comments
procedureSection ::= comments varName SECTION DOT sentences+
sentences ::= procedures+ DOT
procedures ::= comments (displaying | moving | performing | if_clause | GOBACK | init_clause | exec_sql | opening | closing | calling | CONTINUE | reading | nextSentence | adding | eval | unstringing | accepting | computing | subtracting )
subtracting ::= SUBTRACT expr FROM variable
computing ::= COMPUTE variable EQUAL expr
accepting ::= ACCEPT varName FROM functionName
functionName ::= varName
unstringing ::= UNSTRING variable DELIMITED BY expr INTO variable
adding ::= ADD expr TO variable+
reading ::= READ varName [AT END procedures+] [NOT AT END procedures+] END-READ
nextSentence ::= NEXT SENTENCE
closing ::= CLOSE varName
calling ::= CALL expr [USING variable+]
opening ::= OPEN (INPUT | OUTPUT) varName
init_clause ::= INITIALIZE variable+
performing ::= doWhile | while | forEach
doWhile ::= PERFORM varName [UNTIL boolean_expr]
while ::= PERFORM UNTIL boolean_expr procedures+ END-PERFORM
forEach ::= PERFORM VARYING varName FROM number [TO number] BY number UNTIL boolean_expr procedures+ END-PERFORM
moving ::= MOVE expr TO variable+
// Optional, because a sentence closes all open clauses...
if_clause ::= IF boolean_expr procedures* [ELSE procedures*] [END-IF]
eval ::= EVALUATE variable [ALSO variable] whens* END-EVALUATE
whens ::= comments WHEN ((expr [ALSO expr]) | OTHER) procedures*
boolean_expr ::= (boolean_expr_clause OR boolean_expr) | (boolean_expr_clause AND boolean_expr) | boolean_expr_clause
boolean_expr_clause ::= expr (([NOT] EQUAL) | bigger [EQUAL] | smaller [EQUAL] ) expr
expr ::= math | literal | (stringConcat) | variable
math ::= (literal | variable) (plus | minus) (literal | variable)
minus ::= '-'
bigger ::= '>'
smaller ::= '<'
literal ::= string | number | SPACE | HIGH-VALUE | LOW-VALUE | ZERO | NULL

variable ::= varName [LP expr [colon expr] RP] [of_clause]
of_clause ::= (OF | IN) varName
colon ::= ':'

displaying ::= DISPLAY stringConcat
stringConcat ::= (stringVar | variable) +
stringVar ::= string
